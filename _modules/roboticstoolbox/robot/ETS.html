<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>roboticstoolbox.robot.ETS &mdash; Robotics Toolbox for Python  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Robotics Toolbox for Python
            <img src="../../../_static/RobToolBox_RoundLogoB.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../arm.html">Manipulator arms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mobile.html">Mobile robots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../blocks.html">bdsim blocks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Robotics Toolbox for Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>roboticstoolbox.robot.ETS</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for roboticstoolbox.robot.ETS</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@author: Jesse Haviland</span>
<span class="sd">@author: Peter Corke</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">UserList</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">pi</span><span class="p">,</span>
    <span class="n">where</span><span class="p">,</span>
    <span class="nb">all</span><span class="p">,</span>
    <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">zeros</span><span class="p">,</span>
    <span class="n">array</span><span class="p">,</span>
    <span class="n">eye</span><span class="p">,</span>
    <span class="n">array_equal</span><span class="p">,</span>
    <span class="n">sqrt</span><span class="p">,</span>
    <span class="nb">min</span><span class="p">,</span>
    <span class="nb">max</span><span class="p">,</span>
    <span class="n">where</span><span class="p">,</span>
    <span class="n">cross</span><span class="p">,</span>
    <span class="n">flip</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">pinv</span><span class="p">,</span> <span class="n">matrix_rank</span><span class="p">,</span> <span class="n">svd</span><span class="p">,</span> <span class="n">eig</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">SE3</span><span class="p">,</span> <span class="n">SE2</span>
<span class="kn">from</span> <span class="nn">spatialmath.base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">getvector</span><span class="p">,</span>
    <span class="n">issymbol</span><span class="p">,</span>
    <span class="n">tr2jac</span><span class="p">,</span>
    <span class="n">verifymatrix</span><span class="p">,</span>
    <span class="n">tr2jac2</span><span class="p">,</span>
    <span class="n">t2r</span><span class="p">,</span>
    <span class="n">rotvelxform</span><span class="p">,</span>
    <span class="n">simplify</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">roboticstoolbox</span> <span class="kn">import</span> <span class="n">rtb_get_param</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">UserList</span>
<span class="kn">from</span> <span class="nn">spatialmath.base</span> <span class="kn">import</span> <span class="n">issymbol</span><span class="p">,</span> <span class="n">getmatrix</span>
<span class="kn">from</span> <span class="nn">fknm</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ETS_init</span><span class="p">,</span>
    <span class="n">ETS_fkine</span><span class="p">,</span>
    <span class="n">ETS_jacob0</span><span class="p">,</span>
    <span class="n">ETS_jacobe</span><span class="p">,</span>
    <span class="n">ETS_hessian0</span><span class="p">,</span>
    <span class="n">ETS_hessiane</span><span class="p">,</span>
    <span class="n">IK_NR</span><span class="p">,</span>
    <span class="n">IK_GN</span><span class="p">,</span>
    <span class="n">IK_LM_Chan</span><span class="p">,</span>
    <span class="n">IK_LM_Wampler</span><span class="p">,</span>
    <span class="n">IK_LM_Sugihara</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">roboticstoolbox</span> <span class="kn">import</span> <span class="n">rtb_get_param</span>
<span class="kn">from</span> <span class="nn">roboticstoolbox.robot.ET</span> <span class="kn">import</span> <span class="n">ET</span><span class="p">,</span> <span class="n">ET2</span>
<span class="kn">from</span> <span class="nn">spatialmath.base</span> <span class="kn">import</span> <span class="n">getvector</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">SE3</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">version_info</span>

<span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">]</span>

<span class="n">py_ver</span> <span class="o">=</span> <span class="n">version_info</span>

<span class="k">if</span> <span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>

    <span class="n">c_property</span> <span class="o">=</span> <span class="n">cached_property</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">c_property</span> <span class="o">=</span> <span class="nb">property</span>


<span class="k">class</span> <span class="nc">BaseETS</span><span class="p">(</span><span class="n">UserList</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="kc">True</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span> <span class="o">=</span> <span class="n">ETS_init</span><span class="p">(</span>
            <span class="p">[</span><span class="n">et</span><span class="o">.</span><span class="n">fknm</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_m</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># self._fknm = [et.fknm for et in self.data]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty prints the ETS</span>

<span class="sd">        :param q: control how joint variables are displayed</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :return: Pretty printed ETS</span>

<span class="sd">        ``q`` controls how the joint variables are displayed:</span>

<span class="sd">        - None, format depends on number of joint variables</span>
<span class="sd">            - one, display joint variable as q</span>
<span class="sd">            - more, display joint variables as q0, q1, ...</span>
<span class="sd">            - if a joint index was provided, use this value</span>
<span class="sd">        - &quot;&quot;, display all joint variables as empty parentheses ``()``</span>
<span class="sd">        - &quot;θ&quot;, display all joint variables as ``(θ)``</span>
<span class="sd">        - format string with passed joint variables ``(j, j+1)``, so &quot;θ{0}&quot;</span>
<span class="sd">          would display joint variables as θ0, θ1, ... while &quot;θ{1}&quot; would</span>
<span class="sd">          display joint variables as θ1, θ2, ...  ``j`` is either the joint</span>
<span class="sd">          index, if provided, otherwise a sequential value.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz()</span>
<span class="sd">            &gt;&gt;&gt; print(e[:2])</span>
<span class="sd">            &gt;&gt;&gt; print(e)</span>
<span class="sd">            &gt;&gt;&gt; print(e.__str__(&quot;&quot;))</span>
<span class="sd">            &gt;&gt;&gt; print(e.__str__(&quot;θ{0}&quot;))  # numbering from 0</span>
<span class="sd">            &gt;&gt;&gt; print(e.__str__(&quot;θ{1}&quot;))  # numbering from 1</span>
<span class="sd">            &gt;&gt;&gt; # explicit joint indices</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz(jindex=3) * ET.tx(1) * ET.Rz(jindex=4)</span>
<span class="sd">            &gt;&gt;&gt; print(e)</span>
<span class="sd">            &gt;&gt;&gt; print(e.__str__(&quot;θ{0}&quot;))</span>

<span class="sd">        .. note:: Angular parameters are converted to degrees, except if they</span>
<span class="sd">            are symbolic.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath.base import symbol</span>
<span class="sd">            &gt;&gt;&gt; theta, d = symbol(&#39;theta, d&#39;)</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rx(theta) * ET.tx(2) * ET.Rx(45, &#39;deg&#39;) * ET.Ry(0.2) * ET.ty(d)</span>
<span class="sd">            &gt;&gt;&gt; str(e)</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">es</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">unicode</span> <span class="o">=</span> <span class="n">rtb_get_param</span><span class="p">(</span><span class="s2">&quot;unicode&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;q</span><span class="si">{0}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;q&quot;</span>

        <span class="c1"># For et in the object, display it, data comes from properties</span>
        <span class="c1"># which come from the named tuple</span>
        <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">_j</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_j</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">jindex</span>
                    <span class="n">qvar</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>  <span class="c1"># lgtm [py/str-format/surplus-argument]  # noqa</span>
                        <span class="n">_j</span><span class="p">,</span> <span class="n">_j</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>
                <span class="c1"># else:</span>
                <span class="c1">#     qvar = &quot;&quot;</span>

                <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isflip</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(-</span><span class="si">{</span><span class="n">qvar</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">qvar</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">elif</span> <span class="n">et</span><span class="o">.</span><span class="n">isrotation</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">issymbol</span><span class="p">(</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">pi</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">°)&quot;</span>

            <span class="k">elif</span> <span class="n">et</span><span class="o">.</span><span class="n">istranslation</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="si">}</span><span class="s2">)&quot;</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">et</span><span class="o">.</span><span class="n">iselementary</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">es</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unicode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot; </span><span class="se">\u2295</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="k">return</span> <span class="s2">&quot; * &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty string for IPython</span>

<span class="sd">        :param p: pretty printer handle (ignored)</span>
<span class="sd">        :param cycle: pretty printer flag (ignored)</span>

<span class="sd">        Print stringified version when variable is displayed in IPython, ie. on</span>
<span class="sd">        a line by itself.</span>

<span class="sd">        Example::</span>

<span class="sd">            [In [1]: e</span>
<span class="sd">            Out [1]: R(q0) ⊕ tx(1) ⊕ R(q1) ⊕ tx(1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">joint_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get index of joint transforms</span>

<span class="sd">        :return: indices of transforms that are joints</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; e.joint_idx()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">where</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">joints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of the variable ETs with this ETS</span>

<span class="sd">        :return: list of ETs that are joints</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; e.joints()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isjoint</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">jindex_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>  <span class="c1">#</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get set of joint indices</span>

<span class="sd">        :return: set of unique joint indices</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz(jindex=1) * ET.tx(jindex=2) * ET.Rz(jindex=1) * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; e.jointset()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()])</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@c_property</span>
    <span class="k">def</span> <span class="nf">jindices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an array of joint indices</span>

<span class="sd">        :return: array of unique joint indices</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz(jindex=1) * ET.tx(jindex=2) * ET.Rz(jindex=1) * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; e.jointset()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([</span><span class="n">j</span><span class="o">.</span><span class="n">jindex</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()])</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@c_property</span>
    <span class="k">def</span> <span class="nf">qlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Joint limits</span>

<span class="sd">        :return: Array of joint limit values</span>
<span class="sd">        :rtype: ndarray(2,n)</span>
<span class="sd">        :exception ValueError: unset limits for a prismatic joint</span>

<span class="sd">        Limits are extracted from the link objects.  If joints limits are</span>
<span class="sd">        not set for:</span>

<span class="sd">            - a revolute joint [-𝜋. 𝜋] is returned</span>
<span class="sd">            - a prismatic joint an exception is raised</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">            &gt;&gt;&gt; robot = rtb.models.DH.Puma560()</span>
<span class="sd">            &gt;&gt;&gt; robot.qlim</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isrotation</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span>
            <span class="k">elif</span> <span class="n">et</span><span class="o">.</span><span class="n">istranslation</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;undefined prismatic joint limit&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Undefined Joint Type&quot;</span><span class="p">)</span>
            <span class="n">limits</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">limits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Joint structure string</span>

<span class="sd">        :return: A string indicating the joint types</span>

<span class="sd">        A string comprising the characters &#39;R&#39; or &#39;P&#39; which indicate the types</span>
<span class="sd">        of joints in order from left to right.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.tz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; e.structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;R&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isrotation</span> <span class="k">else</span> <span class="s2">&quot;P&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of joints</span>

<span class="sd">        :return: the number of joints in the ETS</span>

<span class="sd">        Counts the number of joints in the ETS.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rx() * ET.tx(1) * ET.tz()</span>
<span class="sd">            &gt;&gt;&gt; e.n</span>

<span class="sd">        :seealso: :func:`joints`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of transforms</span>

<span class="sd">        :return: the number of transforms in the ETS</span>

<span class="sd">        Counts the number of transforms in the ETS.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rx() * ET.tx(1) * ET.tz()</span>
<span class="sd">            &gt;&gt;&gt; e.m</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">]:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">new_data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]):</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">new_data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">]):</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET2</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop value</span>

<span class="sd">        :param i: item in the list to pop, default is last</span>
<span class="sd">        :return: the popped value</span>
<span class="sd">        :raises IndexError: if there are no values to pop</span>

<span class="sd">        Removes a value from the value list and returns it.  The original</span>
<span class="sd">        instance is modified.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; tail = e.pop()</span>
<span class="sd">            &gt;&gt;&gt; tail</span>
<span class="sd">            &gt;&gt;&gt; e</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">item</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">item</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS&quot;</span><span class="p">]:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS2&quot;</span><span class="p">]:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split ETS into link segments</span>

<span class="sd">        Returns a list of ETS, each one, apart from the last,</span>
<span class="sd">        ends with a variable ET.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()):</span>
            <span class="n">ets_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ets_j</span><span class="p">)</span>

        <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">tail_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tail_len</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tail_len</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">tail_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segments</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of ETS</span>

<span class="sd">        :return: Inverse of the ETS</span>

<span class="sd">        The inverse of a given ETS.  It is computed as the inverse of the</span>
<span class="sd">        individual ETs in the reverse order.</span>

<span class="sd">        .. math::</span>

<span class="sd">            (\mathbf{E}_0, \mathbf{E}_1 \cdots \mathbf{E}_{n-1} )^{-1} = (\mathbf{E}_{n-1}^{-1}, \mathbf{E}_{n-2}^{-1} \cdots \mathbf{E}_0^{-1}{n-1} )</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz(jindex=2) * ET.tx(1) * ET.Rx(jindex=3,flip=True) * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; print(e)</span>
<span class="sd">            &gt;&gt;&gt; print(e.inv())</span>

<span class="sd">        .. note:: It is essential to use explicit joint indices to account for</span>
<span class="sd">            the reversed order of the transforms.</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">et</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)])</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET2</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">]:</span>  <span class="c1"># pragma: nocover</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Index or slice an ETS</span>

<span class="sd">        :param i: the index or slince</span>
<span class="sd">        :return: Elementary transform</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; e[0]</span>
<span class="sd">            &gt;&gt;&gt; e[1]</span>
<span class="sd">            &gt;&gt;&gt; e[1:3]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># can be [2] or slice, eg. [3:5]</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">roboticstoolbox.robot.ERobot</span> <span class="kn">import</span> <span class="n">ERobot</span><span class="p">,</span> <span class="n">ERobot2</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">ERobot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">ERobot2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">robot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">teach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">roboticstoolbox.robot.ERobot</span> <span class="kn">import</span> <span class="n">ERobot</span><span class="p">,</span> <span class="n">ERobot2</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">ERobot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">ERobot2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">robot</span><span class="o">.</span><span class="n">teach</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">random_q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a random valid joint configuration</span>

<span class="sd">        :param i: number of configurations to generate</span>

<span class="sd">        Generates a random q vector within the joint limits defined by</span>
<span class="sd">        `self.qlim`.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">            &gt;&gt;&gt; robot = rtb.models.Panda()</span>
<span class="sd">            &gt;&gt;&gt; ets = robot.ets()</span>
<span class="sd">            &gt;&gt;&gt; q = ets.random_q()</span>
<span class="sd">            &gt;&gt;&gt; q</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">q</span>


<div class="viewcode-block" id="ETS"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS">[docs]</a><span class="k">class</span> <span class="nc">ETS</span><span class="p">(</span><span class="n">BaseETS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements an elementary transform sequence (ETS) for 3D</span>

<span class="sd">    :param arg: Function to compute ET value</span>

<span class="sd">    An instance can contain an elementary transform (ET) or an elementary</span>
<span class="sd">    transform sequence (ETS). It has list-like properties by subclassing</span>
<span class="sd">    UserList, which means we can perform indexing, slicing pop, insert, as well</span>
<span class="sd">    as using it as an iterator over its values.</span>

<span class="sd">    - ``ETS()`` an empty ETS list</span>
<span class="sd">    - ``ETS(et)`` an ETS containing a single ET</span>
<span class="sd">    - ``ETS([et0, et1, et2])`` an ETS consisting of three ET&#39;s</span>

<span class="sd">    Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ETS, ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz(0.3) # a single ET, rotation about z</span>
<span class="sd">            &gt;&gt;&gt; ets1 = ETS(e)</span>
<span class="sd">            &gt;&gt;&gt; len(ets1)</span>
<span class="sd">            &gt;&gt;&gt; ets2 = ET.Rz(0.3) * ET.tx(2) # an ETS</span>
<span class="sd">            &gt;&gt;&gt; len(ets2)                    # of length 2</span>
<span class="sd">            &gt;&gt;&gt; ets2[1]                      # an ET sliced from the ETS</span>

<span class="sd">    :references:</span>
<span class="sd">        - Kinematic Derivatives using the Elementary Transform Sequence,</span>
<span class="sd">          J. Haviland and P. Corke</span>

<span class="sd">    :seealso: :func:`rx`, :func:`ry`, :func:`rz`, :func:`tx`,</span>
<span class="sd">        :func:`ty`, :func:`tz`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">ET</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS&quot;</span><span class="p">],</span> <span class="n">ET</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arg&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arg&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if jindices are set</span>
        <span class="n">joints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()</span>

        <span class="c1"># Number of joints with a jindex</span>
        <span class="n">jindices</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Number of joints with a sequential jindex (j[2] -&gt; jindex = 2)</span>
        <span class="n">seq_jindex</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Count them up</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jindices</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">seq_jindex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">seq_jindex</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="c1"># ets has sequential jindicies, except for the last.</span>
            <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You can not have some jindices set for the ET&#39;s in arg. It must be all or none&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Set them ourself</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
                <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="n">j</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ETS.__mul__"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ET&quot;</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ETS</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span></div>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ET&quot;</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ETS</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">rest</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>  <span class="c1"># pragma: nocover</span>

<div class="viewcode-block" id="ETS.compile"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile an ETS</span>

<span class="sd">        :return: optimised ETS</span>

<span class="sd">        Perform constant folding for faster evaluation.  Consecutive constant</span>
<span class="sd">        ETs are compounded, leading to a constant ET which is denoted by</span>
<span class="sd">        ``SE3`` when displayed.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">            &gt;&gt;&gt; robot = rtb.models.ETS.Panda()</span>
<span class="sd">            &gt;&gt;&gt; ets = robot.ets()</span>
<span class="sd">            &gt;&gt;&gt; ets</span>
<span class="sd">            &gt;&gt;&gt; ets.compile()</span>

<span class="sd">        :seealso: :func:`isconstant`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ets</span> <span class="o">=</span> <span class="n">ETS</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="c1"># a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># flush the constant</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
                        <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SE3</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">et</span>  <span class="c1"># emit the joint ET</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># not a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">const</span> <span class="o">@</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># flush the constant, tool transform</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SE3</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ets</span></div>

<div class="viewcode-block" id="ETS.insert"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">],</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert value</span>

<span class="sd">        :param i: insert an ET or ETS into the ETS, default is at the end</span>
<span class="sd">        :param arg: the elementary transform or sequence to insert</span>

<span class="sd">        Inserts an ET or ETS into the ET sequence.  The inserted value is at position</span>
<span class="sd">        ``i``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">            &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; f = ET.Ry()</span>
<span class="sd">            &gt;&gt;&gt; e.insert(f, 2)</span>
<span class="sd">            &gt;&gt;&gt; e</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span></div>

<div class="viewcode-block" id="ETS.fkine"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.fkine">[docs]</a>    <span class="k">def</span> <span class="nf">fkine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>

<span class="sd">        :param q: Joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param base: base transform, optional</span>
<span class="sd">        :param tool: tool transform, optional</span>

<span class="sd">        :return: The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        - ``T = ets.fkine(q)`` evaluates forward kinematics for the robot at</span>
<span class="sd">          joint configuration ``q``.</span>
<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE3`` instance with ``m`` values.</span>
<span class="sd">        .. note::</span>
<span class="sd">            - The robot&#39;s base tool transform, if set, is incorporated</span>
<span class="sd">              into the result.</span>
<span class="sd">            - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">            - Works from the end-effector link to the base</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Empty</span><span class="p">()</span>
        <span class="n">fk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
            <span class="c1"># symbolic</span>
            <span class="n">fk</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">fk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">fk</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SE3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">fk</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>

<span class="sd">        :param q: Joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param base: base transform, optional</span>
<span class="sd">        :param tool: tool transform, optional</span>

<span class="sd">        :return: The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        - ``T = ets.fkine(q)`` evaluates forward kinematics for the robot at</span>
<span class="sd">          joint configuration ``q``.</span>
<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE3`` instance with ``m`` values.</span>
<span class="sd">        .. note::</span>
<span class="sd">            - The robot&#39;s base tool transform, if set, is incorporated</span>
<span class="sd">              into the result.</span>
<span class="sd">            - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">            - Works from the end-effector link to the base</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_fkine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">getmatrix</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># type: ignore</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="n">tool</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">tool</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">base</span>

        <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">tool</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="c1"># Tk = None</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">qk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
            <span class="n">link</span> <span class="o">=</span> <span class="n">end</span>  <span class="c1"># start with last link</span>

            <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>

            <span class="n">Tk</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">tools</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">Tk</span> <span class="o">@</span> <span class="n">tools</span>

            <span class="c1"># add remaining links, back toward the base</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Tk</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># add base transform if it is set</span>
            <span class="k">if</span> <span class="n">include_base</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">bases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">bases</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># append</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Tk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">Tk</span>

        <span class="k">return</span> <span class="n">T</span>

<div class="viewcode-block" id="ETS.jacob0"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.jacob0">[docs]</a>    <span class="k">def</span> <span class="nf">jacob0</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jacobian in base frame</span>
<span class="sd">        :param q: Joint coordinate vector</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param tool: a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>
<span class="sd">        :return J: Manipulator Jacobian in the base frame</span>
<span class="sd">        ``jacob0(q)`` is the ETS Jacobian matrix which maps joint</span>
<span class="sd">        velocity to spatial velocity in the {0} frame.</span>
<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x,</span>
<span class="sd">        \omega_y, \omega_z)^T` is related to joint velocity by</span>
<span class="sd">        :math:`{}^{e}\nu = {}^{e}\mathbf{J}_0(q) \dot{q}`.</span>
<span class="sd">        If ``ets.eval(q)`` is already computed it can be passed in as ``T`` to</span>
<span class="sd">        reduce computation time.</span>
<span class="sd">        An ETS represents the relative pose from the {0} frame to the end frame</span>
<span class="sd">        {e}. This is the composition of mAny relative poses, some constant and</span>
<span class="sd">        some functions of the joint variables, which we can write as</span>
<span class="sd">        :math:`\mathbf{E}(q)`.</span>
<span class="sd">        .. math::</span>
<span class="sd">            {}^0 T_e = \mathbf{E}(q) \in \mbox{SE}(3)</span>
<span class="sd">        The temporal derivative of this is the spatial</span>
<span class="sd">        velocity :math:`\nu` which is a 6-vector is related to the rate of</span>
<span class="sd">        change of joint coordinates by the Jacobian matrix.</span>
<span class="sd">        .. math::</span>
<span class="sd">           {}^0 \nu = {}^0 \mathbf{J}(q) \dot{q} \in \mathbb{R}^6</span>
<span class="sd">        This velocity can be expressed relative to the {0} frame or the {e}</span>
<span class="sd">        frame.</span>
<span class="sd">        :references:</span>
<span class="sd">            - `Kinematic Derivatives using the Elementary Transform Sequence, J. Haviland and P. Corke &lt;https://arxiv.org/abs/2010.08696&gt;`_</span>
<span class="sd">        :seealso: :func:`jacobe`, :func:`hessian0`</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_jacob0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Otherwise use Python</span>
        <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">tool</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">include_base</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">@</span> <span class="n">tools</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>

            <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

                <span class="k">if</span> <span class="n">link</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                    <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">tools</span>

                <span class="n">Tu</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="n">T</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">Tu</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">Tu</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">Tu</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;Rz&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;Ry&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;Rx&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;tx&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;ty&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;tz&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span>

                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">A</span>

        <span class="k">return</span> <span class="n">J</span></div>

<div class="viewcode-block" id="ETS.jacobe"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.jacobe">[docs]</a>    <span class="k">def</span> <span class="nf">jacobe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator geometric Jacobian in the end-effector frame</span>

<span class="sd">        :param q: Joint coordinate vector</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param tool: a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        :return J: Manipulator Jacobian in the end-effector frame</span>

<span class="sd">        - ``ets.jacobe(q)`` is the manipulator Jacobian matrix which maps</span>
<span class="sd">          joint  velocity to end-effector spatial velocity expressed in the</span>
<span class="sd">          end-effector frame.</span>
<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        is related to joint velocity by :math:`{}^{E}\!\nu = \mathbf{J}_m(q) \dot{q}`.</span>

<span class="sd">        .. warning:: This is the **geometric Jacobian** as described in texts by</span>
<span class="sd">            Corke, Spong etal., Siciliano etal.  The end-effector velocity is</span>
<span class="sd">            described in terms of translational and angular velocity, not a</span>
<span class="sd">            velocity twist as per the text by Lynch &amp; Park.</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_jacobe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tr2jac</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span></div>

<div class="viewcode-block" id="ETS.hessian0"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.hessian0">[docs]</a>    <span class="k">def</span> <span class="nf">hessian0</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">J0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator Hessian</span>

<span class="sd">        The manipulator Hessian tensor maps joint acceleration to end-effector</span>
<span class="sd">        spatial acceleration, expressed in the world-coordinate frame. This</span>
<span class="sd">        function calulcates this based on the ETS of the robot.</span>
<span class="sd">        </span>
<span class="sd">        One of J0 or q</span>
<span class="sd">        is required. Supply J0 if already calculated to save computation time</span>

<span class="sd">        :param q: The joint angles/configuration of the robot.</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param J0: The manipulator Jacobian in the 0 frame</span>
<span class="sd">        :param tool: a static tool transformation matrix to apply to the</span>
<span class="sd">            end frame, defaults to None</span>

<span class="sd">        :return: The manipulator Hessian in 0 frame</span>

<span class="sd">        This method computes the manipulator Hessian in the base frame.  If</span>
<span class="sd">        we take the time derivative of the differential kinematic relationship</span>
<span class="sd">        .. math::</span>
<span class="sd">            \nu    &amp;= \mat{J}(\vec{q}) \dvec{q} \\</span>
<span class="sd">            \alpha &amp;= \dmat{J} \dvec{q} + \mat{J} \ddvec{q}</span>
<span class="sd">        where</span>
<span class="sd">        .. math::</span>
<span class="sd">            \dmat{J} = \mat{H} \dvec{q}</span>
<span class="sd">        and :math:`\mat{H} \in \mathbb{R}^{6\times n \times n}` is the</span>
<span class="sd">        Hessian tensor.</span>
<span class="sd">        The elements of the Hessian are</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{H}_{i,j,k} =  \frac{d^2 u_i}{d q_j d q_k}</span>
<span class="sd">        where :math:`u = \{t_x, t_y, t_z, r_x, r_y, r_z\}` are the elements</span>
<span class="sd">        of the spatial velocity vector.</span>
<span class="sd">        Similarly, we can write</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{J}_{i,j} = \frac{d u_i}{d q_j}</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_hessian0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">J0</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="k">if</span> <span class="n">J0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">J0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verifymatrix</span><span class="p">(</span><span class="n">J0</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>

                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">J0</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">J0</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">J0</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">J0</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="ETS.hessiane"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.hessiane">[docs]</a>    <span class="k">def</span> <span class="nf">hessiane</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Je</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator Hessian</span>

<span class="sd">        The manipulator Hessian tensor maps joint acceleration to end-effector</span>
<span class="sd">        spatial acceleration, expressed in the world-coordinate frame. This</span>
<span class="sd">        function calulcates this based on the ETS of the robot.</span>
<span class="sd">        </span>
<span class="sd">        One of Je or q</span>
<span class="sd">        is required. Supply Je if already calculated to save computation time</span>

<span class="sd">        :param q: The joint angles/configuration of the robot.</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param Je: The manipulator Jacobian in the ee frame</span>
<span class="sd">        :param tool: a static tool transformation matrix to apply to the</span>
<span class="sd">            end frame, defaults to None</span>

<span class="sd">        :return: The manipulator Hessian in ee frame</span>

<span class="sd">        This method computes the manipulator Hessian in the ee frame.  If</span>
<span class="sd">        we take the time derivative of the differential kinematic relationship</span>
<span class="sd">        .. math::</span>
<span class="sd">            \nu    &amp;= \mat{J}(\vec{q}) \dvec{q} \\</span>
<span class="sd">            \alpha &amp;= \dmat{J} \dvec{q} + \mat{J} \ddvec{q}</span>
<span class="sd">        where</span>
<span class="sd">        .. math::</span>
<span class="sd">            \dmat{J} = \mat{H} \dvec{q}</span>
<span class="sd">        and :math:`\mat{H} \in \mathbb{R}^{6\times n \times n}` is the</span>
<span class="sd">        Hessian tensor.</span>
<span class="sd">        The elements of the Hessian are</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{H}_{i,j,k} =  \frac{d^2 u_i}{d q_j d q_k}</span>
<span class="sd">        where :math:`u = \{t_x, t_y, t_z, r_x, r_y, r_z\}` are the elements</span>
<span class="sd">        of the spatial velocity vector.</span>
<span class="sd">        Similarly, we can write</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{J}_{i,j} = \frac{d u_i}{d q_j}</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_hessiane</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">Je</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="k">if</span> <span class="n">Je</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">Je</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobe</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verifymatrix</span><span class="p">(</span><span class="n">Je</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>

                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">Je</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Je</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">Je</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Je</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">H</span></div>

    <span class="k">def</span> <span class="nf">jacob0_analytical</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">representation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rpy/xyz&quot;</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator analytical Jacobian in the base frame</span>

<span class="sd">        :param q: Joint coordinate vector</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param tool: a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>
<span class="sd">        :param representation: describes the rotational representation</span>

<span class="sd">        :return J: Manipulator Jacobian in the base frame</span>

<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        is related to joint velocity by :math:`{}^{E}\!\nu = \mathbf{J}_m(q) \dot{q}`.</span>

<span class="sd">        ==================   ==================================</span>
<span class="sd">        ``representation``          Rotational representation</span>
<span class="sd">        ==================   ==================================</span>
<span class="sd">        ``&#39;rpy/xyz&#39;``        RPY angular rates in XYZ order</span>
<span class="sd">        ``&#39;rpy/zyx&#39;``        RPY angular rates in XYZ order</span>
<span class="sd">        ``&#39;eul&#39;``            Euler angular rates in ZYZ order</span>
<span class="sd">        ``&#39;exp&#39;``            exponential coordinate rates</span>
<span class="sd">        ==================   ==================================</span>

<span class="sd">        Example:</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">            &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">            &gt;&gt;&gt; puma = rtb.models.ETS.Puma560()</span>
<span class="sd">            &gt;&gt;&gt; puma.jacob0_analytical([0, 0, 0, 0, 0, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">rotvelxform</span><span class="p">(</span><span class="n">t2r</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">representation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">@</span> <span class="n">J</span>

    <span class="k">def</span> <span class="nf">jacobm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the manipulability Jacobian. This measure relates the rate</span>
<span class="sd">        of change of the manipulability to the joint velocities of the robot.</span>

<span class="sd">        :param q: The joint angles/configuration of the robot (Optional,</span>
<span class="sd">            if not supplied will use the stored q values).</span>

<span class="sd">        :return: The manipulability Jacobian</span>
<span class="sd">        :rtype: float ndarray(n)</span>

<span class="sd">        Yoshikawa&#39;s manipulability measure</span>

<span class="sd">        .. math::</span>

<span class="sd">            m(\vec{q}) = \sqrt{\mat{J}(\vec{q}) \mat{J}(\vec{q})^T}</span>

<span class="sd">        This method returns its Jacobian with respect to configuration</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\partial m(\vec{q})}{\partial \vec{q}}</span>

<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessian0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="n">manipulability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manipulability</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="c1"># J = J[axes, :]</span>
        <span class="c1"># H = H[:, axes, :]</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">J</span> <span class="o">@</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">Jm</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">J</span> <span class="o">@</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Jm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">manipulability</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">b</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Jm</span>

    <span class="k">def</span> <span class="nf">manipulability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;yoshikawa&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulability measure</span>

<span class="sd">        :param q: Joint coordinates, one of J or q required</span>
<span class="sd">        :type q: ndarray(n), or ndarray(m,n)</span>
<span class="sd">        :param J: Jacobian in world frame if already computed, one of J or</span>
<span class="sd">            q required</span>
<span class="sd">        :type J: ndarray(6,n)</span>
<span class="sd">        :param method: method to use, &quot;yoshikawa&quot; (default), &quot;condition&quot;,</span>
<span class="sd">            &quot;minsingular&quot;  or &quot;asada&quot;</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param axes: Task space axes to consider: &quot;all&quot; [default],</span>
<span class="sd">            &quot;trans&quot;, &quot;rot&quot; or &quot;both&quot;</span>
<span class="sd">        :type axes: str</span>
<span class="sd">        :param kwargs: extra arguments to pass to ``jacob0``</span>
<span class="sd">        :return: manipulability</span>
<span class="sd">        :rtype: float or ndarray(m)</span>

<span class="sd">        - ``manipulability(q)`` is the scalar manipulability index</span>
<span class="sd">          for the robot at the joint configuration ``q``.  It indicates</span>
<span class="sd">          dexterity, that is, how well conditioned the robot is for motion</span>
<span class="sd">          with respect to the 6 degrees of Cartesian motion.  The values is</span>
<span class="sd">          zero if the robot is at a singularity.</span>

<span class="sd">        Various measures are supported:</span>

<span class="sd">        +-------------------+-------------------------------------------------+</span>
<span class="sd">        | Measure           |       Description                               |</span>
<span class="sd">        +-------------------+-------------------------------------------------+</span>
<span class="sd">        | ``&quot;yoshikawa&quot;``   | Volume of the velocity ellipsoid, *distance*    |</span>
<span class="sd">        |                   | from singularity [Yoshikawa85]_                 |</span>
<span class="sd">        +-------------------+-------------------------------------------------+</span>
<span class="sd">        | ``&quot;invcondition&quot;``| Inverse condition number of Jacobian, isotropy  |</span>
<span class="sd">        |                   | of the velocity ellipsoid [Klein87]_            |</span>
<span class="sd">        +-------------------+-------------------------------------------------+</span>
<span class="sd">        | ``&quot;minsingular&quot;`` | Minimum singular value of the Jacobian,         |</span>
<span class="sd">        |                   | *distance*  from singularity [Klein87]_         |</span>
<span class="sd">        +-------------------+-------------------------------------------------+</span>
<span class="sd">        | ``&quot;asada&quot;``       | Isotropy of the task-space acceleration         |</span>
<span class="sd">        |                   | ellipsoid which is a function of the Cartesian  |</span>
<span class="sd">        |                   | inertia matrix which depends on the inertial    |</span>
<span class="sd">        |                   | parameters [Asada83]_                           |</span>
<span class="sd">        +-------------------+-------------------------------------------------+</span>

<span class="sd">        **Trajectory operation**:</span>

<span class="sd">        If ``q`` is a matrix (m,n) then the result (m,) is a vector of</span>
<span class="sd">        manipulability indices for each joint configuration specified by a row</span>
<span class="sd">        of ``q``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Invokes the ``jacob0`` method of the robot if ``J`` is not passed</span>
<span class="sd">            - The &quot;all&quot; option includes rotational and translational</span>
<span class="sd">              dexterity, but this involves adding different units. It can be</span>
<span class="sd">              more useful to look at the translational and rotational</span>
<span class="sd">              manipulability separately.</span>
<span class="sd">            - Examples in the RVC book (1st edition) can be replicated by</span>
<span class="sd">              using the &quot;all&quot; option</span>
<span class="sd">            - Asada&#39;s measure requires inertial a robot model with inertial</span>
<span class="sd">              parameters.</span>

<span class="sd">        :references:</span>

<span class="sd">        .. [Yoshikawa85] Manipulability of Robotic Mechanisms. Yoshikawa T.,</span>
<span class="sd">                The International Journal of Robotics Research.</span>
<span class="sd">                1985;4(2):3-9. doi:10.1177/027836498500400201</span>
<span class="sd">        .. [Asada83] A geometrical representation of manipulator dynamics and</span>
<span class="sd">                its application to arm design, H. Asada,</span>
<span class="sd">                Journal of Dynamic Systems, Measurement, and Control,</span>
<span class="sd">                vol. 105, p. 131, 1983.</span>
<span class="sd">        .. [Klein87] Dexterity Measures for the Design and Control of</span>
<span class="sd">                Kinematically Redundant Manipulators. Klein CA, Blaho BE.</span>
<span class="sd">                The International Journal of Robotics Research.</span>
<span class="sd">                1987;6(2):72-83. doi:10.1177/027836498700600206</span>

<span class="sd">        - Robotics, Vision &amp; Control, Chap 8, P. Corke, Springer 2011.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">yoshikawa</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">axes</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># simplified case for square matrix</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">J</span> <span class="o">@</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">axes</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">minsingular</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">axes</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># return last/smallest singular value of J</span>

        <span class="k">def</span> <span class="nf">asada</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># dof = np.sum(axes)</span>
            <span class="k">if</span> <span class="n">matrix_rank</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">Ji</span> <span class="o">=</span> <span class="n">pinv</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
            <span class="n">Mx</span> <span class="o">=</span> <span class="n">Ji</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">robot</span><span class="o">.</span><span class="n">inertia</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">@</span> <span class="n">Ji</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">axes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Mx</span> <span class="o">=</span> <span class="n">Mx</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="n">Mx</span> <span class="o">=</span> <span class="n">Mx</span><span class="p">[:,</span> <span class="n">d</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
            <span class="n">e</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">Mx</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="c1"># choose the handler function</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;yoshikawa&quot;</span><span class="p">:</span>
            <span class="n">mfunc</span> <span class="o">=</span> <span class="n">yoshikawa</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;invcondition&quot;</span><span class="p">:</span>
            <span class="n">mfunc</span> <span class="o">=</span> <span class="n">condition</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;minsingular&quot;</span><span class="p">:</span>
            <span class="n">mfunc</span> <span class="o">=</span> <span class="n">minsingular</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;asada&quot;</span><span class="p">:</span>
            <span class="n">mfunc</span> <span class="o">=</span> <span class="n">asada</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method chosen&quot;</span><span class="p">)</span>

        <span class="c1"># q = getmatrix(q, (None, self.n))</span>
        <span class="c1"># w = zeros(q.shape[0])</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>

        <span class="c1"># for k, qk in enumerate(q):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">mfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

        <span class="c1"># if len(w) == 1:</span>
        <span class="c1">#     return w[0]</span>
        <span class="c1"># else:</span>
        <span class="k">return</span> <span class="n">w</span>

    <span class="k">def</span> <span class="nf">partial_fkine0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator Forward Kinematics nth Partial Derivative</span>

<span class="sd">        The manipulator Hessian tensor maps joint acceleration to end-effector</span>
<span class="sd">        spatial acceleration, expressed in the ee frame. This</span>
<span class="sd">        function calulcates this based on the ETS of the robot. One of Je or q</span>
<span class="sd">        is required. Supply Je if already calculated to save computation time</span>

<span class="sd">        :param q: The joint angles/configuration of the robot (Optional,</span>
<span class="sd">            if not supplied will use the stored q values).</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param end: the final link/Gripper which the Hessian represents</span>
<span class="sd">        :param start: the first link which the Hessian represents</span>
<span class="sd">        :param tool: a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        :return: The nth Partial Derivative of the forward kinematics</span>

<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">                Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Calculate the Jacobian and Hessian</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessian0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="c1"># A list of derivatives, starting with the jacobian and hessian</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="p">[</span><span class="n">J</span><span class="p">,</span> <span class="n">H</span><span class="p">]</span>

        <span class="c1"># The tensor dimensions of the latest derivative</span>
        <span class="c1"># Set to the current size of the Hessian</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">]</span>

        <span class="c1"># An array which keeps track of the index of the partial derivative</span>
        <span class="c1"># we are calculating</span>
        <span class="c1"># It stores the indices in the order: &quot;j, k, l. m, n, o, ...&quot;</span>
        <span class="c1"># where count is extended to match oder of the partial derivative</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># The order of derivative for which we are calculating</span>
        <span class="c1"># The Hessian is the 2nd-order so we start with c = 2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">def</span> <span class="nf">add_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">new_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># if even number</span>
                    <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if odd number</span>
                    <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">new_indices</span>

        <span class="k">def</span> <span class="nf">add_pdi</span><span class="p">(</span><span class="n">pdi</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">new_pdi</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">new_pdi</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># if even number</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># if odd number</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">new_pdi</span>

        <span class="c1"># these are the indices used for the hessian</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>

        <span class="c1"># The partial derivative indices (pdi)</span>
        <span class="c1"># the are the pd indices used in the cross products</span>
        <span class="n">pdi</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># The length of dT correspods to the number of derivatives we have calculated</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">dT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>

            <span class="c1"># Add to the start of the tensor size list</span>
            <span class="n">size</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="c1"># Add an axis to the count array</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">count</span><span class="p">))</span>

            <span class="c1"># This variables corresponds to indices within the previous partial derivatives</span>
            <span class="c1"># to be cross prodded</span>
            <span class="c1"># The order is: &quot;[j, k, l, m, n, o, ...]&quot;</span>
            <span class="c1"># Although, our partial derivatives have the order: pd[..., o, n, m, l, k, cartesian DoF, j]</span>
            <span class="c1"># For example, consider the Hessian Tensor H[n, 6, n], the index H[k, :, j]. This corrsponds</span>
            <span class="c1"># to the second partial derivative of the kinematics of joint j with respect to joint k.</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">add_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

            <span class="c1"># This variable corresponds to the indices in Td which corresponds to the</span>
            <span class="c1"># partial derivatives we need to use</span>
            <span class="n">pdi</span> <span class="o">=</span> <span class="n">add_pdi</span><span class="p">(</span><span class="n">pdi</span><span class="p">)</span>

            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Allocate our new partial derivative tensor</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

            <span class="c1"># We need to loop n^c times</span>
            <span class="c1"># There are n^c columns to calculate</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">**</span><span class="n">c</span><span class="p">):</span>

                <span class="c1"># Allocate the rotation and translation components</span>
                <span class="n">rot</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">trn</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                <span class="c1"># This loop calculates a single column ([trn, rot]) of the tensor for dT(x)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
                    <span class="n">pdr0</span> <span class="o">=</span> <span class="n">dT</span><span class="p">[</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">pdr1</span> <span class="o">=</span> <span class="n">dT</span><span class="p">[</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="n">idx0</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">idx1</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="c1"># This is a list of indices selecting the slices of the previous tensor</span>
                    <span class="n">idx0_slices</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">idx0</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">idx1_slices</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">idx1</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="c1"># This index selecting the column within the 2d slice of the previous tensor</span>
                    <span class="n">idx0_n</span> <span class="o">=</span> <span class="n">idx0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">idx1_n</span> <span class="o">=</span> <span class="n">idx1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Use our indices to select the rotational column from pdr0 and pdr1</span>
                    <span class="n">col0_rot</span> <span class="o">=</span> <span class="n">pdr0</span><span class="p">[(</span><span class="o">*</span><span class="n">idx0_slices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">idx0_n</span><span class="p">)]</span>
                    <span class="n">col1_rot</span> <span class="o">=</span> <span class="n">pdr1</span><span class="p">[(</span><span class="o">*</span><span class="n">idx1_slices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">idx1_n</span><span class="p">)]</span>

                    <span class="c1"># Use our indices to select the translational column from pdr1</span>
                    <span class="n">col1_trn</span> <span class="o">=</span> <span class="n">pdr1</span><span class="p">[(</span><span class="o">*</span><span class="n">idx1_slices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">idx1_n</span><span class="p">)]</span>

                    <span class="c1"># Perform the cross product as described in the maths above</span>
                    <span class="n">rot</span> <span class="o">+=</span> <span class="n">cross</span><span class="p">(</span><span class="n">col0_rot</span><span class="p">,</span> <span class="n">col1_rot</span><span class="p">)</span>
                    <span class="n">trn</span> <span class="o">+=</span> <span class="n">cross</span><span class="p">(</span><span class="n">col0_rot</span><span class="p">,</span> <span class="n">col1_trn</span><span class="p">)</span>

                <span class="n">pd</span><span class="p">[(</span><span class="o">*</span><span class="n">flip</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">trn</span>
                <span class="n">pd</span><span class="p">[(</span><span class="o">*</span><span class="n">flip</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">rot</span>

                <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">dT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dT</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">ik_lm_chan</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">reject_jl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">we</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">λ</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Numerical inverse kinematics by Levenberg-Marquadt optimization (Chan&#39;s Method)</span>

<span class="sd">        :param Tep: The desired end-effector pose or pose trajectory</span>
<span class="sd">        :param q0: initial joint configuration (default to random valid joint</span>
<span class="sd">            configuration contrained by the joint limits of the robot)</span>
<span class="sd">        :param ilimit: maximum number of iterations per search</span>
<span class="sd">        :param slimit: maximum number of search attempts</span>
<span class="sd">        :param tol: final error tolerance</span>
<span class="sd">        :param reject_jl: constrain the solution to being within the joint limits of</span>
<span class="sd">            the robot (reject solution with invalid joint configurations and perfrom</span>
<span class="sd">            another search up to the slimit)</span>
<span class="sd">        :param we: a mask vector which weights the end-effector error priority.</span>
<span class="sd">            Corresponds to translation in X, Y and Z and rotation about X, Y and Z</span>
<span class="sd">            respectively</span>
<span class="sd">        :param λ: value of lambda for the damping matrix Wn</span>

<span class="sd">        :return: inverse kinematic solution</span>
<span class="sd">        :rtype: tuple (q, success, iterations, searches, residual)</span>

<span class="sd">        ``sol = ets.ik_lm_chan(Tep)`` are the joint coordinates (n) corresponding</span>
<span class="sd">        to the robot end-effector pose ``Tep`` which is an ``SE3`` or ``ndarray`` object.</span>
<span class="sd">        This method can be used for robots with any number of degrees of freedom.</span>
<span class="sd">        The return value ``sol`` is a tuple with elements:</span>

<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        Element         Type        Description</span>
<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        ``q``           ndarray(n)  joint coordinates in units of radians or metres</span>
<span class="sd">        ``success``     int         whether a solution was found</span>
<span class="sd">        ``iterations``  int         total number of iterations</span>
<span class="sd">        ``searches``    int         total number of searches</span>
<span class="sd">        ``residual``    float       final value of cost function</span>
<span class="sd">        ============    ==========  ===============================================</span>

<span class="sd">        If ``success == 0`` the ``q`` values will be valid numbers, but the</span>
<span class="sd">        solution will be in error.  The amount of error is indicated by</span>
<span class="sd">        the ``residual``.</span>

<span class="sd">        **Joint Limits**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, slimit=100)`` which is the deafualt for this method.</span>
<span class="sd">        The solver will initialise a solution attempt with a random valid q0 and</span>
<span class="sd">        perform a maximum of ilimit steps within this attempt. If a solution is not</span>
<span class="sd">        found, this process is repeated up to slimit times.</span>

<span class="sd">        **Global search**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, reject_jl=True)`` is the deafualt for this method.</span>
<span class="sd">        By setting reject_jl to True, the solver will discard any solution which</span>
<span class="sd">        violates the defined joint limits of the robot. The solver will then</span>
<span class="sd">        re-initialise with a new random q0 and repeat the process up to slimit times.</span>
<span class="sd">        Note that finding a solution with valid joint coordinates takes longer than</span>
<span class="sd">        without.</span>

<span class="sd">        **Underactuated robots:**</span>

<span class="sd">        For the case where the manipulator has fewer than 6 DOF the</span>
<span class="sd">        solution space has more dimensions than can be spanned by the</span>
<span class="sd">        manipulator joint coordinates.</span>

<span class="sd">        In this case we specify the ``we`` option where the ``we`` vector</span>
<span class="sd">        (6) specifies the Cartesian DOF (in the wrist coordinate frame) that</span>
<span class="sd">        will be ignored in reaching a solution.  The we vector has six</span>
<span class="sd">        elements that correspond to translation in X, Y and Z, and rotation</span>
<span class="sd">        about X, Y and Z respectively. The value can be 0 (for ignore)</span>
<span class="sd">        or above to assign a priority relative to other Cartesian DoF. The number</span>
<span class="sd">        of non-zero elements must equal the number of manipulator DOF.</span>

<span class="sd">        For example when using a 3 DOF manipulator tool orientation might</span>
<span class="sd">        be unimportant, in which case use the option ``we=[1, 1, 1, 0, 0, 0]``.</span>



<span class="sd">        .. note::</span>

<span class="sd">            - See `Toolbox kinematics wiki page</span>
<span class="sd">                &lt;https://github.com/petercorke/robotics-toolbox-python/wiki/Kinematics&gt;`_</span>
<span class="sd">            - Implements a Levenberg-Marquadt variable-damping solver.</span>
<span class="sd">            - The tolerance is computed on the norm of the error between</span>
<span class="sd">                current and desired tool pose.  This norm is computed from</span>
<span class="sd">                distances and angles without any kind of weighting.</span>
<span class="sd">            - The inverse kinematic solution is generally not unique, and</span>
<span class="sd">                depends on the initial guess ``q0``.</span>

<span class="sd">        :references:</span>
<span class="sd">            TODO</span>

<span class="sd">        :seealso:</span>
<span class="sd">            TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IK_LM_Chan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">ilimit</span><span class="p">,</span> <span class="n">slimit</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">reject_jl</span><span class="p">,</span> <span class="n">we</span><span class="p">,</span> <span class="n">λ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ik_lm_wampler</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">reject_jl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">we</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">λ</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Numerical inverse kinematics by Levenberg-Marquadt optimization (Chan&#39;s Method)</span>

<span class="sd">        :param Tep: The desired end-effector pose or pose trajectory</span>
<span class="sd">        :param q0: initial joint configuration (default to random valid joint</span>
<span class="sd">            configuration contrained by the joint limits of the robot)</span>
<span class="sd">        :param ilimit: maximum number of iterations per search</span>
<span class="sd">        :param slimit: maximum number of search attempts</span>
<span class="sd">        :param tol: final error tolerance</span>
<span class="sd">        :param reject_jl: constrain the solution to being within the joint limits of</span>
<span class="sd">            the robot (reject solution with invalid joint configurations and perfrom</span>
<span class="sd">            another search up to the slimit)</span>
<span class="sd">        :param we: a mask vector which weights the end-effector error priority.</span>
<span class="sd">            Corresponds to translation in X, Y and Z and rotation about X, Y and Z</span>
<span class="sd">            respectively</span>
<span class="sd">        :param λ: value of lambda for the damping matrix Wn</span>

<span class="sd">        :return: inverse kinematic solution</span>
<span class="sd">        :rtype: tuple (q, success, iterations, searches, residual)</span>

<span class="sd">        ``sol = ets.ik_lm_chan(Tep)`` are the joint coordinates (n) corresponding</span>
<span class="sd">        to the robot end-effector pose ``Tep`` which is an ``SE3`` or ``ndarray`` object.</span>
<span class="sd">        This method can be used for robots with any number of degrees of freedom.</span>
<span class="sd">        The return value ``sol`` is a tuple with elements:</span>

<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        Element         Type        Description</span>
<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        ``q``           ndarray(n)  joint coordinates in units of radians or metres</span>
<span class="sd">        ``success``     int         whether a solution was found</span>
<span class="sd">        ``iterations``  int         total number of iterations</span>
<span class="sd">        ``searches``    int         total number of searches</span>
<span class="sd">        ``residual``    float       final value of cost function</span>
<span class="sd">        ============    ==========  ===============================================</span>

<span class="sd">        If ``success == 0`` the ``q`` values will be valid numbers, but the</span>
<span class="sd">        solution will be in error.  The amount of error is indicated by</span>
<span class="sd">        the ``residual``.</span>

<span class="sd">        **Joint Limits**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, slimit=100)`` which is the deafualt for this method.</span>
<span class="sd">        The solver will initialise a solution attempt with a random valid q0 and</span>
<span class="sd">        perform a maximum of ilimit steps within this attempt. If a solution is not</span>
<span class="sd">        found, this process is repeated up to slimit times.</span>

<span class="sd">        **Global search**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, reject_jl=True)`` is the deafualt for this method.</span>
<span class="sd">        By setting reject_jl to True, the solver will discard any solution which</span>
<span class="sd">        violates the defined joint limits of the robot. The solver will then</span>
<span class="sd">        re-initialise with a new random q0 and repeat the process up to slimit times.</span>
<span class="sd">        Note that finding a solution with valid joint coordinates takes longer than</span>
<span class="sd">        without.</span>

<span class="sd">        **Underactuated robots:**</span>

<span class="sd">        For the case where the manipulator has fewer than 6 DOF the</span>
<span class="sd">        solution space has more dimensions than can be spanned by the</span>
<span class="sd">        manipulator joint coordinates.</span>

<span class="sd">        In this case we specify the ``we`` option where the ``we`` vector</span>
<span class="sd">        (6) specifies the Cartesian DOF (in the wrist coordinate frame) that</span>
<span class="sd">        will be ignored in reaching a solution.  The we vector has six</span>
<span class="sd">        elements that correspond to translation in X, Y and Z, and rotation</span>
<span class="sd">        about X, Y and Z respectively. The value can be 0 (for ignore)</span>
<span class="sd">        or above to assign a priority relative to other Cartesian DoF. The number</span>
<span class="sd">        of non-zero elements must equal the number of manipulator DOF.</span>

<span class="sd">        For example when using a 3 DOF manipulator tool orientation might</span>
<span class="sd">        be unimportant, in which case use the option ``we=[1, 1, 1, 0, 0, 0]``.</span>



<span class="sd">        .. note::</span>

<span class="sd">            - See `Toolbox kinematics wiki page</span>
<span class="sd">                &lt;https://github.com/petercorke/robotics-toolbox-python/wiki/Kinematics&gt;`_</span>
<span class="sd">            - Implements a Levenberg-Marquadt variable-damping solver.</span>
<span class="sd">            - The tolerance is computed on the norm of the error between</span>
<span class="sd">                current and desired tool pose.  This norm is computed from</span>
<span class="sd">                distances and angles without any kind of weighting.</span>
<span class="sd">            - The inverse kinematic solution is generally not unique, and</span>
<span class="sd">                depends on the initial guess ``q0``.</span>

<span class="sd">        :references:</span>
<span class="sd">            TODO</span>

<span class="sd">        :seealso:</span>
<span class="sd">            TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IK_LM_Wampler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">ilimit</span><span class="p">,</span> <span class="n">slimit</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">reject_jl</span><span class="p">,</span> <span class="n">we</span><span class="p">,</span> <span class="n">λ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ik_lm_sugihara</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">reject_jl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">we</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">λ</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Numerical inverse kinematics by Levenberg-Marquadt optimization (Chan&#39;s Method)</span>

<span class="sd">        :param Tep: The desired end-effector pose or pose trajectory</span>
<span class="sd">        :param q0: initial joint configuration (default to random valid joint</span>
<span class="sd">            configuration contrained by the joint limits of the robot)</span>
<span class="sd">        :param ilimit: maximum number of iterations per search</span>
<span class="sd">        :param slimit: maximum number of search attempts</span>
<span class="sd">        :param tol: final error tolerance</span>
<span class="sd">        :param reject_jl: constrain the solution to being within the joint limits of</span>
<span class="sd">            the robot (reject solution with invalid joint configurations and perfrom</span>
<span class="sd">            another search up to the slimit)</span>
<span class="sd">        :param we: a mask vector which weights the end-effector error priority.</span>
<span class="sd">            Corresponds to translation in X, Y and Z and rotation about X, Y and Z</span>
<span class="sd">            respectively</span>
<span class="sd">        :param λ: value of lambda for the damping matrix Wn</span>

<span class="sd">        :return: inverse kinematic solution</span>
<span class="sd">        :rtype: tuple (q, success, iterations, searches, residual)</span>

<span class="sd">        ``sol = ets.ik_lm_chan(Tep)`` are the joint coordinates (n) corresponding</span>
<span class="sd">        to the robot end-effector pose ``Tep`` which is an ``SE3`` or ``ndarray`` object.</span>
<span class="sd">        This method can be used for robots with any number of degrees of freedom.</span>
<span class="sd">        The return value ``sol`` is a tuple with elements:</span>

<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        Element         Type        Description</span>
<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        ``q``           ndarray(n)  joint coordinates in units of radians or metres</span>
<span class="sd">        ``success``     int         whether a solution was found</span>
<span class="sd">        ``iterations``  int         total number of iterations</span>
<span class="sd">        ``searches``    int         total number of searches</span>
<span class="sd">        ``residual``    float       final value of cost function</span>
<span class="sd">        ============    ==========  ===============================================</span>

<span class="sd">        If ``success == 0`` the ``q`` values will be valid numbers, but the</span>
<span class="sd">        solution will be in error.  The amount of error is indicated by</span>
<span class="sd">        the ``residual``.</span>

<span class="sd">        **Joint Limits**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, slimit=100)`` which is the deafualt for this method.</span>
<span class="sd">        The solver will initialise a solution attempt with a random valid q0 and</span>
<span class="sd">        perform a maximum of ilimit steps within this attempt. If a solution is not</span>
<span class="sd">        found, this process is repeated up to slimit times.</span>

<span class="sd">        **Global search**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, reject_jl=True)`` is the deafualt for this method.</span>
<span class="sd">        By setting reject_jl to True, the solver will discard any solution which</span>
<span class="sd">        violates the defined joint limits of the robot. The solver will then</span>
<span class="sd">        re-initialise with a new random q0 and repeat the process up to slimit times.</span>
<span class="sd">        Note that finding a solution with valid joint coordinates takes longer than</span>
<span class="sd">        without.</span>

<span class="sd">        **Underactuated robots:**</span>

<span class="sd">        For the case where the manipulator has fewer than 6 DOF the</span>
<span class="sd">        solution space has more dimensions than can be spanned by the</span>
<span class="sd">        manipulator joint coordinates.</span>

<span class="sd">        In this case we specify the ``we`` option where the ``we`` vector</span>
<span class="sd">        (6) specifies the Cartesian DOF (in the wrist coordinate frame) that</span>
<span class="sd">        will be ignored in reaching a solution.  The we vector has six</span>
<span class="sd">        elements that correspond to translation in X, Y and Z, and rotation</span>
<span class="sd">        about X, Y and Z respectively. The value can be 0 (for ignore)</span>
<span class="sd">        or above to assign a priority relative to other Cartesian DoF. The number</span>
<span class="sd">        of non-zero elements must equal the number of manipulator DOF.</span>

<span class="sd">        For example when using a 3 DOF manipulator tool orientation might</span>
<span class="sd">        be unimportant, in which case use the option ``we=[1, 1, 1, 0, 0, 0]``.</span>



<span class="sd">        .. note::</span>

<span class="sd">            - See `Toolbox kinematics wiki page</span>
<span class="sd">                &lt;https://github.com/petercorke/robotics-toolbox-python/wiki/Kinematics&gt;`_</span>
<span class="sd">            - Implements a Levenberg-Marquadt variable-damping solver.</span>
<span class="sd">            - The tolerance is computed on the norm of the error between</span>
<span class="sd">                current and desired tool pose.  This norm is computed from</span>
<span class="sd">                distances and angles without any kind of weighting.</span>
<span class="sd">            - The inverse kinematic solution is generally not unique, and</span>
<span class="sd">                depends on the initial guess ``q0``.</span>

<span class="sd">        :references:</span>
<span class="sd">            TODO</span>

<span class="sd">        :seealso:</span>
<span class="sd">            TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IK_LM_Sugihara</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">ilimit</span><span class="p">,</span> <span class="n">slimit</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">reject_jl</span><span class="p">,</span> <span class="n">we</span><span class="p">,</span> <span class="n">λ</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ik_nr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">reject_jl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">we</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_pinv</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pinv_damping</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Numerical inverse kinematics by Levenberg-Marquadt optimization (Chan&#39;s Method)</span>

<span class="sd">        :param Tep: The desired end-effector pose or pose trajectory</span>
<span class="sd">        :param q0: initial joint configuration (default to random valid joint</span>
<span class="sd">            configuration contrained by the joint limits of the robot)</span>
<span class="sd">        :param ilimit: maximum number of iterations per search</span>
<span class="sd">        :param slimit: maximum number of search attempts</span>
<span class="sd">        :param tol: final error tolerance</span>
<span class="sd">        :param reject_jl: constrain the solution to being within the joint limits of</span>
<span class="sd">            the robot (reject solution with invalid joint configurations and perfrom</span>
<span class="sd">            another search up to the slimit)</span>
<span class="sd">        :param we: a mask vector which weights the end-effector error priority.</span>
<span class="sd">            Corresponds to translation in X, Y and Z and rotation about X, Y and Z</span>
<span class="sd">            respectively</span>
<span class="sd">        :param λ: value of lambda for the damping matrix Wn</span>

<span class="sd">        :return: inverse kinematic solution</span>
<span class="sd">        :rtype: tuple (q, success, iterations, searches, residual)</span>

<span class="sd">        ``sol = ets.ik_lm_chan(Tep)`` are the joint coordinates (n) corresponding</span>
<span class="sd">        to the robot end-effector pose ``Tep`` which is an ``SE3`` or ``ndarray`` object.</span>
<span class="sd">        This method can be used for robots with any number of degrees of freedom.</span>
<span class="sd">        The return value ``sol`` is a tuple with elements:</span>

<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        Element         Type        Description</span>
<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        ``q``           ndarray(n)  joint coordinates in units of radians or metres</span>
<span class="sd">        ``success``     int         whether a solution was found</span>
<span class="sd">        ``iterations``  int         total number of iterations</span>
<span class="sd">        ``searches``    int         total number of searches</span>
<span class="sd">        ``residual``    float       final value of cost function</span>
<span class="sd">        ============    ==========  ===============================================</span>

<span class="sd">        If ``success == 0`` the ``q`` values will be valid numbers, but the</span>
<span class="sd">        solution will be in error.  The amount of error is indicated by</span>
<span class="sd">        the ``residual``.</span>

<span class="sd">        **Joint Limits**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, slimit=100)`` which is the deafualt for this method.</span>
<span class="sd">        The solver will initialise a solution attempt with a random valid q0 and</span>
<span class="sd">        perform a maximum of ilimit steps within this attempt. If a solution is not</span>
<span class="sd">        found, this process is repeated up to slimit times.</span>

<span class="sd">        **Global search**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, reject_jl=True)`` is the deafualt for this method.</span>
<span class="sd">        By setting reject_jl to True, the solver will discard any solution which</span>
<span class="sd">        violates the defined joint limits of the robot. The solver will then</span>
<span class="sd">        re-initialise with a new random q0 and repeat the process up to slimit times.</span>
<span class="sd">        Note that finding a solution with valid joint coordinates takes longer than</span>
<span class="sd">        without.</span>

<span class="sd">        **Underactuated robots:**</span>

<span class="sd">        For the case where the manipulator has fewer than 6 DOF the</span>
<span class="sd">        solution space has more dimensions than can be spanned by the</span>
<span class="sd">        manipulator joint coordinates.</span>

<span class="sd">        In this case we specify the ``we`` option where the ``we`` vector</span>
<span class="sd">        (6) specifies the Cartesian DOF (in the wrist coordinate frame) that</span>
<span class="sd">        will be ignored in reaching a solution.  The we vector has six</span>
<span class="sd">        elements that correspond to translation in X, Y and Z, and rotation</span>
<span class="sd">        about X, Y and Z respectively. The value can be 0 (for ignore)</span>
<span class="sd">        or above to assign a priority relative to other Cartesian DoF. The number</span>
<span class="sd">        of non-zero elements must equal the number of manipulator DOF.</span>

<span class="sd">        For example when using a 3 DOF manipulator tool orientation might</span>
<span class="sd">        be unimportant, in which case use the option ``we=[1, 1, 1, 0, 0, 0]``.</span>



<span class="sd">        .. note::</span>

<span class="sd">            - See `Toolbox kinematics wiki page</span>
<span class="sd">                &lt;https://github.com/petercorke/robotics-toolbox-python/wiki/Kinematics&gt;`_</span>
<span class="sd">            - Implements a Levenberg-Marquadt variable-damping solver.</span>
<span class="sd">            - The tolerance is computed on the norm of the error between</span>
<span class="sd">                current and desired tool pose.  This norm is computed from</span>
<span class="sd">                distances and angles without any kind of weighting.</span>
<span class="sd">            - The inverse kinematic solution is generally not unique, and</span>
<span class="sd">                depends on the initial guess ``q0``.</span>

<span class="sd">        :references:</span>
<span class="sd">            TODO</span>

<span class="sd">        :seealso:</span>
<span class="sd">            TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IK_NR</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span>
            <span class="n">Tep</span><span class="p">,</span>
            <span class="n">q0</span><span class="p">,</span>
            <span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="p">,</span>
            <span class="n">reject_jl</span><span class="p">,</span>
            <span class="n">we</span><span class="p">,</span>
            <span class="n">use_pinv</span><span class="p">,</span>
            <span class="n">pinv_damping</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ik_gn</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">reject_jl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">we</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_pinv</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pinv_damping</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Numerical inverse kinematics by Levenberg-Marquadt optimization (Chan&#39;s Method)</span>

<span class="sd">        :param Tep: The desired end-effector pose or pose trajectory</span>
<span class="sd">        :param q0: initial joint configuration (default to random valid joint</span>
<span class="sd">            configuration contrained by the joint limits of the robot)</span>
<span class="sd">        :param ilimit: maximum number of iterations per search</span>
<span class="sd">        :param slimit: maximum number of search attempts</span>
<span class="sd">        :param tol: final error tolerance</span>
<span class="sd">        :param reject_jl: constrain the solution to being within the joint limits of</span>
<span class="sd">            the robot (reject solution with invalid joint configurations and perfrom</span>
<span class="sd">            another search up to the slimit)</span>
<span class="sd">        :param we: a mask vector which weights the end-effector error priority.</span>
<span class="sd">            Corresponds to translation in X, Y and Z and rotation about X, Y and Z</span>
<span class="sd">            respectively</span>
<span class="sd">        :param λ: value of lambda for the damping matrix Wn</span>

<span class="sd">        :return: inverse kinematic solution</span>
<span class="sd">        :rtype: tuple (q, success, iterations, searches, residual)</span>

<span class="sd">        ``sol = ets.ik_lm_chan(Tep)`` are the joint coordinates (n) corresponding</span>
<span class="sd">        to the robot end-effector pose ``Tep`` which is an ``SE3`` or ``ndarray`` object.</span>
<span class="sd">        This method can be used for robots with any number of degrees of freedom.</span>
<span class="sd">        The return value ``sol`` is a tuple with elements:</span>

<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        Element         Type        Description</span>
<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        ``q``           ndarray(n)  joint coordinates in units of radians or metres</span>
<span class="sd">        ``success``     int         whether a solution was found</span>
<span class="sd">        ``iterations``  int         total number of iterations</span>
<span class="sd">        ``searches``    int         total number of searches</span>
<span class="sd">        ``residual``    float       final value of cost function</span>
<span class="sd">        ============    ==========  ===============================================</span>

<span class="sd">        If ``success == 0`` the ``q`` values will be valid numbers, but the</span>
<span class="sd">        solution will be in error.  The amount of error is indicated by</span>
<span class="sd">        the ``residual``.</span>

<span class="sd">        **Joint Limits**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, slimit=100)`` which is the deafualt for this method.</span>
<span class="sd">        The solver will initialise a solution attempt with a random valid q0 and</span>
<span class="sd">        perform a maximum of ilimit steps within this attempt. If a solution is not</span>
<span class="sd">        found, this process is repeated up to slimit times.</span>

<span class="sd">        **Global search**:</span>

<span class="sd">        ``sol = robot.ikine_LM(T, reject_jl=True)`` is the deafualt for this method.</span>
<span class="sd">        By setting reject_jl to True, the solver will discard any solution which</span>
<span class="sd">        violates the defined joint limits of the robot. The solver will then</span>
<span class="sd">        re-initialise with a new random q0 and repeat the process up to slimit times.</span>
<span class="sd">        Note that finding a solution with valid joint coordinates takes longer than</span>
<span class="sd">        without.</span>

<span class="sd">        **Underactuated robots:**</span>

<span class="sd">        For the case where the manipulator has fewer than 6 DOF the</span>
<span class="sd">        solution space has more dimensions than can be spanned by the</span>
<span class="sd">        manipulator joint coordinates.</span>

<span class="sd">        In this case we specify the ``we`` option where the ``we`` vector</span>
<span class="sd">        (6) specifies the Cartesian DOF (in the wrist coordinate frame) that</span>
<span class="sd">        will be ignored in reaching a solution.  The we vector has six</span>
<span class="sd">        elements that correspond to translation in X, Y and Z, and rotation</span>
<span class="sd">        about X, Y and Z respectively. The value can be 0 (for ignore)</span>
<span class="sd">        or above to assign a priority relative to other Cartesian DoF. The number</span>
<span class="sd">        of non-zero elements must equal the number of manipulator DOF.</span>

<span class="sd">        For example when using a 3 DOF manipulator tool orientation might</span>
<span class="sd">        be unimportant, in which case use the option ``we=[1, 1, 1, 0, 0, 0]``.</span>



<span class="sd">        .. note::</span>

<span class="sd">            - See `Toolbox kinematics wiki page</span>
<span class="sd">                &lt;https://github.com/petercorke/robotics-toolbox-python/wiki/Kinematics&gt;`_</span>
<span class="sd">            - Implements a Levenberg-Marquadt variable-damping solver.</span>
<span class="sd">            - The tolerance is computed on the norm of the error between</span>
<span class="sd">                current and desired tool pose.  This norm is computed from</span>
<span class="sd">                distances and angles without any kind of weighting.</span>
<span class="sd">            - The inverse kinematic solution is generally not unique, and</span>
<span class="sd">                depends on the initial guess ``q0``.</span>

<span class="sd">        :references:</span>
<span class="sd">            TODO</span>

<span class="sd">        :seealso:</span>
<span class="sd">            TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IK_GN</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span>
            <span class="n">Tep</span><span class="p">,</span>
            <span class="n">q0</span><span class="p">,</span>
            <span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="p">,</span>
            <span class="n">reject_jl</span><span class="p">,</span>
            <span class="n">we</span><span class="p">,</span>
            <span class="n">use_pinv</span><span class="p">,</span>
            <span class="n">pinv_damping</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ETS2"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2">[docs]</a><span class="k">class</span> <span class="nc">ETS2</span><span class="p">(</span><span class="n">BaseETS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements an elementary transform sequence (ETS) for 2D</span>

<span class="sd">    :param arg: Function to compute ET value</span>

<span class="sd">    An instance can contain an elementary transform (ET) or an elementary</span>
<span class="sd">    transform sequence (ETS). It has list-like properties by subclassing</span>
<span class="sd">    UserList, which means we can perform indexing, slicing pop, insert, as well</span>
<span class="sd">    as using it as an iterator over its values.</span>

<span class="sd">    - ``ETS()`` an empty ETS list</span>
<span class="sd">    - ``ET2.XY(η)`` is a constant elementary transform</span>
<span class="sd">    - ``ET2.XY(η, &#39;deg&#39;)`` as above but the angle is expressed in degrees</span>
<span class="sd">    - ``ET2.XY()`` is a joint variable, the value is left free until evaluation</span>
<span class="sd">      time</span>
<span class="sd">    - ``ET2.XY(j=J)`` as above but the joint index is explicitly given, this</span>
<span class="sd">      might correspond to the joint number of a multi-joint robot.</span>
<span class="sd">    - ``ET2.XY(flip=True)`` as above but the joint moves in the opposite sense</span>

<span class="sd">    where ``XY`` is one of ``R``, ``tx``, ``ty``.</span>

<span class="sd">    Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ETS2 as ET2</span>
<span class="sd">            &gt;&gt;&gt; e = ET2.R(0.3)  # a single ET, rotation about z</span>
<span class="sd">            &gt;&gt;&gt; len(e)</span>
<span class="sd">            &gt;&gt;&gt; e = ET2.R(0.3) * ET2.tx(2)  # an ETS</span>
<span class="sd">            &gt;&gt;&gt; len(e)                      # of length 2</span>
<span class="sd">            &gt;&gt;&gt; e[1]                        # an ET sliced from the ETS</span>

<span class="sd">    :references:</span>
<span class="sd">        - Kinematic Derivatives using the Elementary Transform Sequence,</span>
<span class="sd">          J. Haviland and P. Corke</span>

<span class="sd">    :seealso: :func:`r`, :func:`tx`, :func:`ty`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">ET2</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS2&quot;</span><span class="p">],</span> <span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ETS2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bad arg&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arg&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ndims</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if jindices are set</span>
        <span class="n">joints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()</span>

        <span class="c1"># Number of joints with a jindex</span>
        <span class="n">jindices</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Number of joints with a sequential jindex (j[2] -&gt; jindex = 2)</span>
        <span class="n">seq_jindex</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Count them up</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jindices</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">seq_jindex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">seq_jindex</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="c1"># ets has sequential jindicies, except for the last.</span>
            <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You can not have some jindices set for the ET&#39;s in arg. It must be all or none&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Set them ourself</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
                <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ETS2.__mul__"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ETS2</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS2</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span></div>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ETS2</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">rest</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>  <span class="c1"># pragma: nocover</span>

<div class="viewcode-block" id="ETS2.compile"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile an ETS2</span>

<span class="sd">        :return: optimised ETS2</span>

<span class="sd">        Perform constant folding for faster evaluation.  Consecutive constant</span>
<span class="sd">        ETs are compounded, leading to a constant ET which is denoted by</span>
<span class="sd">        ``SE3`` when displayed.</span>

<span class="sd">        :seealso: :func:`isconstant`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ets</span> <span class="o">=</span> <span class="n">ETS2</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="c1"># a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># flush the constant</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
                        <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET2</span><span class="o">.</span><span class="n">SE2</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">et</span>  <span class="c1"># emit the joint ET</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># not a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">const</span> <span class="o">@</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># flush the constant, tool transform</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET2</span><span class="o">.</span><span class="n">SE2</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ets</span></div>

<div class="viewcode-block" id="ETS2.insert"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">],</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert value</span>

<span class="sd">        :param i: insert an ET or ETS into the ETS, default is at the end</span>
<span class="sd">        :param arg: the elementary transform or sequence to insert</span>

<span class="sd">        Inserts an ET or ETS into the ET sequence.  The inserted value is at position</span>
<span class="sd">        ``i``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET2</span>
<span class="sd">            &gt;&gt;&gt; e = ET2.R() * ET2.tx(1) * ET2.R() * ET2.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; f = ET2.R()</span>
<span class="sd">            &gt;&gt;&gt; e.insert(f, 2)</span>
<span class="sd">            &gt;&gt;&gt; e</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span></div>

<div class="viewcode-block" id="ETS2.fkine"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.fkine">[docs]</a>    <span class="k">def</span> <span class="nf">fkine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE2</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>
<span class="sd">        :param q: Joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param base: base transform, optional</span>
<span class="sd">        :param tool: tool transform, optional</span>

<span class="sd">        :return: The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        - ``T = ets.fkine(q)`` evaluates forward kinematics for the robot at</span>
<span class="sd">          joint configuration ``q``.</span>
<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE2`` instance with ``m`` values.</span>
<span class="sd">        .. note::</span>
<span class="sd">            - The robot&#39;s base tool transform, if set, is incorporated</span>
<span class="sd">              into the result.</span>
<span class="sd">            - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">            - Works from the end-effector link to the base</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">SE2</span><span class="o">.</span><span class="n">Empty</span><span class="p">()</span>
        <span class="n">fk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
            <span class="c1"># symbolic</span>
            <span class="n">fk</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">fk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">fk</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SE2</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">SE2</span><span class="p">(</span><span class="n">fk</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>
<span class="sd">        :param q: Joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param base: base transform, optional</span>
<span class="sd">        :param tool: tool transform, optional</span>

<span class="sd">        :return: The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        - ``T = ets.fkine(q)`` evaluates forward kinematics for the robot at</span>
<span class="sd">          joint configuration ``q``.</span>
<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE2`` instance with ``m`` values.</span>
<span class="sd">        .. note::</span>
<span class="sd">            - The robot&#39;s base tool transform, if set, is incorporated</span>
<span class="sd">              into the result.</span>
<span class="sd">            - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">            - Works from the end-effector link to the base</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">getmatrix</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># type: ignore</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SE2</span><span class="p">):</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">base</span>

        <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">SE2</span><span class="p">):</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">tool</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array_equal</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">tool</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">qk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
            <span class="n">link</span> <span class="o">=</span> <span class="n">end</span>  <span class="c1"># start with last link</span>

            <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>
            <span class="n">Tk</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">tools</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">Tk</span> <span class="o">@</span> <span class="n">tools</span>

            <span class="c1"># add remaining links, back toward the base</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Tk</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># add base transform if it is set</span>
            <span class="k">if</span> <span class="n">include_base</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">bases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">bases</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># append</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Tk</span>
                <span class="c1"># ret.append(SE2(Tk, check=False))  # type: ignore</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">Tk</span>
                <span class="c1"># ret = SE2(Tk, check=False)</span>

        <span class="k">return</span> <span class="n">T</span>

<div class="viewcode-block" id="ETS2.jacob0"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.jacob0">[docs]</a>    <span class="k">def</span> <span class="nf">jacob0</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># very inefficient implementation, just put a 1 in last row</span>
        <span class="c1"># if its a rotation joint</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="n">etjoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">etjoints</span><span class="p">])):</span>
            <span class="c1"># not all joints have a jindex it is required, set them</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">etjoints</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="n">j</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">etjoints</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jindex</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># pragma: nocover</span>

            <span class="c1"># jindex = 0 if self[i].jindex is None else self[i].jindex</span>

            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="o">@</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="p">(</span>
                    <span class="n">q</span><span class="p">[</span><span class="n">jindex</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;tx&quot;</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;ty&quot;</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid axes&quot;</span><span class="p">)</span>

            <span class="n">E0</span> <span class="o">=</span> <span class="n">ETS2</span><span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">E0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">E0</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="n">dTdq</span>

            <span class="n">Ef</span> <span class="o">=</span> <span class="n">ETS2</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ef</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">dTdq</span> <span class="o">@</span> <span class="n">Ef</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">A</span>

            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">A</span>
            <span class="n">dRdt</span> <span class="o">=</span> <span class="n">dTdq</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">T</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

            <span class="n">J</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dTdq</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dRdt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">J</span></div>

<div class="viewcode-block" id="ETS2.jacobe"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.jacobe">[docs]</a>    <span class="k">def</span> <span class="nf">jacobe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jacobian in base frame</span>

<span class="sd">        :param q: joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :return: Jacobian matrix</span>

<span class="sd">        ``jacobe(q)`` is the manipulator Jacobian matrix which maps joint</span>
<span class="sd">        velocity to end-effector spatial velocity.</span>

<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        is related to joint velocity by :math:`{}^{e}\nu = {}^{e}\mathbf{J}_0(q) \dot{q}`.</span>

<span class="sd">        :seealso: :func:`jacob`, :func:`hessian0`</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">include_base</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">A</span>
        <span class="k">return</span> <span class="n">tr2jac2</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span></div></div>


<span class="c1"># if __name__ == &quot;__main__&quot;:</span>

<span class="c1">#     from roboticstoolbox import models</span>

<span class="c1">#     ur5 = models.URDF.UR5()</span>

<span class="c1">#     ur5.fkine(ur5.qz)</span>
<span class="c1">#     ur5.jacob0(ur5.qz)</span>
<span class="c1">#     ur5.jacob0_analytic(ur5.qz)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Jesse Haviland and Peter Corke.
      <span class="lastupdated">Last updated on 13-Sep-2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>